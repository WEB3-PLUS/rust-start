### 1. **ایجاد پروژه با Cargo**

برای شروع یک پروژه جدید در Rust، می‌توانید از دستور زیر استفاده کنید:

```bash
cargo new projectName
```

این دستور یک دایرکتوری جدید به نام `projectName` ایجاد می‌کند و در آن یک پروژه جدید با ساختار اولیه و فایل‌های لازم (از جمله `Cargo.toml` و یک فایل `main.rs`) ایجاد می‌کند.

### 2. **ساخت پروژه**

برای ساخت پروژه، از دستور زیر استفاده می‌شود:

```bash
cargo build
```

این دستور کد شما را کامپایل می‌کند و فایل‌های اجرایی را در دایرکتوری `target/debug` ذخیره می‌کند. این دایرکتوری حاوی باینری‌هایی است که برای توسعه و تست استفاده می‌شوند.

### 3. **اجرای پروژه**

برای اجرای برنامه‌ی Rust، می‌توانید از یکی از دو روش زیر استفاده کنید:

- **اجرای مستقیم باینری:**

  ```bash
  ./target/debug/projectName
  ```

  این روش به شما امکان می‌دهد تا باینری ساخته شده را به صورت مستقیم اجرا کنید.

- **استفاده از Cargo:**
  ```bash
  cargo run
  ```
  این دستور به طور خودکار کد شما را کامپایل کرده و سپس آن را اجرا می‌کند. این روش برای توسعه‌دهندگان بسیار راحت‌تر است، زیرا نیازی به یادآوری مسیر باینری نیست.

### 4. **بررسی کد بدون تولید باینری**

اگر می‌خواهید کد خود را بررسی کنید و مطمئن شوید که بدون خطا کامپایل می‌شود، می‌توانید از دستور زیر استفاده کنید:

```bash
cargo check
```

این دستور کد شما را سریعاً بررسی می‌کند، اما باینری تولید نمی‌کند. این ویژگی برای شناسایی سریع خطاها و مشکلات در کد بسیار مفید است.

### 5. **ساخت پروژه برای انتشار**

زمانی که پروژه شما آماده‌ی انتشار است و می‌خواهید آن را با بهینه‌سازی‌های لازم کامپایل کنید، می‌توانید از دستور زیر استفاده کنید:

```bash
cargo build --release
```

این دستور کد شما را با بهینه‌سازی‌های خاصی کامپایل می‌کند و باینری تولید شده را در دایرکتوری `target/release` ذخیره می‌کند. باینری‌های تولید شده در این دایرکتوری معمولاً سریع‌تر و بهینه‌تر هستند و برای استفاده در محیط‌های تولید توصیه می‌شوند.

### 6. **بنچمارک‌گیری**

اگر قصد دارید زمان اجرای کد خود را بنچمارک کنید، مهم است که از باینری موجود در `target/release` استفاده کنید. این باینری بهینه‌سازی شده است و نتایج دقیق‌تری از عملکرد کد شما ارائه می‌دهد.

<hr/>

### کد کامل بازی حدس عدد

```rust
use rand::Rng; // برای تولید اعداد تصادفی
use std::cmp::Ordering; // برای مقایسه مقادیر
use std::io; // برای ورودی و خروجی

fn main() {
    println!("guess the number:");

    // تولید یک عدد تصادفی بین 1 تا 100
    let secret_number = rand::thread_rng().gen_range(1..=100);

    // چاپ عدد مخفی (برای تست)
    println!("the secret number is: {secret_number}");

    loop {
        println!("please input your guess");

        let mut guess = String::new(); // ایجاد یک رشته خالی برای ورودی کاربر
        io::stdin()
            .read_line(&mut guess) // خواندن ورودی کاربر
            .expect("failed to read line"); // مدیریت خطا

        println!("you guessed: {guess}"); // چاپ حدس کاربر

        // تبدیل ورودی کاربر به عدد
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num, // اگر تبدیل موفق بود، عدد را ذخیره کن
            Err(_) => continue, // اگر خطا بود، حلقه را ادامه بده
        };

        // مقایسه حدس کاربر با عدد مخفی
        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"), // اگر حدس کمتر بود
            Ordering::Greater => println!("Too big!"), // اگر حدس بیشتر بود
            Ordering::Equal => {
                println!("You win!"); // اگر حدس برابر بود
                return; // پایان بازی
            }
        }
    }
}
```

### 1. **وارد کردن کتابخانه‌ها**

```rust
use rand::Rng; // برای تولید اعداد تصادفی
use std::cmp::Ordering; // برای مقایسه مقادیر
use std::io; // برای ورودی و خروجی
```

- **`use rand::Rng;`**: این خط ماژول `Rng` از کتابخانه `rand` را وارد می‌کند که برای تولید اعداد تصادفی استفاده می‌شود. این ماژول توابعی را برای تولید اعداد تصادفی فراهم می‌کند.
- **`use std::cmp::Ordering;`**: ماژول `Ordering` شامل سه حالت `Less`, `Greater`, و `Equal` است که برای مقایسه مقادیر استفاده می‌شود. این مقادیر به ما اجازه می‌دهند تا بفهمیم یک عدد کمتر، بیشتر یا برابر با عدد دیگر است.
- **`use std::io;`**: ماژول `io` برای کار با ورودی و خروجی در Rust استفاده می‌شود. ما از آن برای خواندن ورودی کاربر استفاده خواهیم کرد.

### 2. **تابع اصلی**

```rust
fn main() {
    println!("guess the number:");
```

- **`fn main()`**: این تابع نقطه شروع هر برنامه Rust است. هر برنامه Rust باید یک تابع `main` داشته باشد.
- **`println!`**: این ماکرو برای چاپ متن به کنسول استفاده می‌شود. در اینجا، به کاربر اعلام می‌شود که باید عددی را حدس بزند.

### 3. **تولید عدد تصادفی**

```rust
let secret_number = rand::thread_rng().gen_range(1..=100);
```

- **`rand::thread_rng()`**: این تابع یک ژنراتور تصادفی برای ترد فعلی ایجاد می‌کند. این ژنراتور برای تولید اعداد تصادفی استفاده می‌شود.
- **`gen_range(1..=100)`**: این تابع یک عدد تصادفی در بازه 1 تا 100 (شامل هر دو) تولید می‌کند. علامت `..=` نشان‌دهنده این است که انتهای بازه نیز شامل می‌شود.

### 4. **چاپ عدد مخفی (برای تست)**

```rust
println!("the secret number is: {secret_number}");
```

- این خط عدد مخفی را چاپ می‌کند. این کار برای تست مفید است، اما در یک بازی واقعی باید این خط را حذف کرد تا کاربر نتواند عدد مخفی را ببیند.

### 5. **حلقه اصلی بازی**

```rust
loop {
    println!("please input your guess");
```

- **`loop { ... }`**: این یک حلقه بی‌نهایت است که به کاربر اجازه می‌دهد تا حدس‌های خود را وارد کند. حلقه تا زمانی که کاربر برنده نشود یا برنامه به صورت دستی متوقف نشود، ادامه خواهد داشت.

### 6. **خواندن ورودی کاربر**

```rust
let mut guess = String::new(); // ایجاد یک رشته خالی برای ورودی کاربر
io::stdin()
    .read_line(&mut guess) // خواندن ورودی کاربر
    .expect("failed to read line"); // مدیریت خطا
```

- **`let mut guess = String::new();`**: یک رشته خالی به نام `guess` ایجاد می‌شود. `mut` به این معنی است که این متغیر قابل تغییر است.
- **`io::stdin().read_line(&mut guess)`**: این خط ورودی کاربر را از کنسول می‌خواند و آن را در متغیر `guess` ذخیره می‌کند. `&mut guess` به این معناست که ما به تابع اجازه می‌دهیم تا محتوای این متغیر را تغییر دهد.
- **`.expect("failed to read line")`**: این متد در صورت بروز خطا، یک پیام خطا چاپ می‌کند و برنامه را متوقف می‌کند. این کار برای اطمینان از این است که ورودی به درستی خوانده شده است.

### 7. **چاپ حدس کاربر**

```rust
println!("you guessed: {guess}"); // چاپ حدس کاربر
```

- این خط حدس کاربر را چاپ می‌کند. این کار برای تأیید به کاربر است که ورودی او به درستی خوانده شده است.

### 8. **تبدیل ورودی به عدد**

```rust
let guess: u32 = match guess.trim().parse() {
    Ok(num) => num, // اگر تبدیل موفق بود، عدد را ذخیره کن
    Err(_) => continue, // اگر خطا بود، حلقه را ادامه بده
};
```

- **`guess.trim()`**: این متد فضای خالی را از ابتدا و انتهای رشته حذف می‌کند. این کار برای جلوگیری از خطا در تبدیل رشته به عدد ضروری است.
- **`.parse()`**: این متد سعی می‌کند رشته را به نوع عددی تبدیل کند. در اینجا ما از `u32` (عدد صحیح غیر منفی) استفاده می‌کنیم.
- **`match`**: این ساختار برای بررسی نتیجه‌ی `parse()` استفاده می‌شود:
  - **`Ok(num)`**: اگر تبدیل موفق باشد، عدد در متغیر `num` ذخیره می‌شود و به متغیر `guess` نسبت داده می‌شود.
  - **`Err(_)`**: اگر تبدیل با خطا مواجه شود (به عنوان مثال، اگر کاربر چیزی غیر از عدد وارد نکند)، حلقه دوباره شروع می‌شود و از کاربر خواسته می‌شود که دوباره حدس بزند.

### 9. **مقایسه حدس با عدد مخفی**

```rust
match guess.cmp(&secret_number) {
    Ordering::Less => println!("Too small!"), // اگر حدس کمتر بود
    Ordering::Greater => println!("Too big!"), // اگر حدس بیشتر بود
    Ordering::Equal => {
        println!("You win!"); // اگر حدس برابر بود
        return; // پایان بازی
    }
}
```

- **`guess.cmp(&secret_number)`**: این متد مقایسه‌ای بین `guess` و `secret_number` انجام می‌دهد و نتیجه را به یکی از مقادیر `Ordering` (کمتر، بیشتر، برابر) برمی‌گرداند.
- **`match`**: با توجه به نتیجه مقایسه، یکی از سه حالت زیر اجرا می‌شود:
  - **`Ordering::Less`**: اگر حدس کاربر کمتر از عدد مخفی باشد، پیام "Too small!" چاپ می‌شود.
  - **`Ordering::Greater`**: اگر حدس کاربر بیشتر از عدد مخفی باشد، پیام "Too big!" چاپ می‌شود.
  - **`Ordering::Equal`**: اگر حدس برابر با عدد مخفی باشد، پیام "You win!" چاپ می‌شود و با استفاده از `return` از تابع `main` خارج می‌شود، که به معنای پایان بازی است.

### 10. **پایان حلقه و برنامه**

- اگر کاربر حدس صحیح را بزند، برنامه خاتمه می‌یابد. در غیر این صورت، حلقه ادامه می‌یابد و از کاربر خواسته می‌شود که دوباره حدس بزند.

### نکات اضافی

- **مدیریت خطا**: در این برنامه، از `expect` برای مدیریت خطاها استفاده شده است. این روش ساده است، اما در برنامه‌های بزرگ‌تر، ممکن است بخواهید از مدیریت خطای پیچیده‌تری استفاده کنید تا به کاربر اطلاعات بیشتری بدهید.
- **توسعه و بهبود**: این بازی می‌تواند با افزودن ویژگی‌های جدید مانند شمارش تعداد حدس‌ها، ارائه گزینه‌های دوباره بازی، یا ذخیره‌سازی رکوردها بهبود یابد.
- **استفاده از ماژول‌ها**: اگر برنامه بزرگ‌تر شود، می‌توانید از ماژول‌ها برای سازماندهی کد خود استفاده کنید. Rust به شما اجازه می‌دهد تا کد خود را به ماژول‌های مختلف تقسیم کنید که به مدیریت بهتر پروژه کمک می‌کند.
